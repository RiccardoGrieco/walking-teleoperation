###############
### ROBOT
###############
remote_control_boards   ("left_arm")
remote_sensor_boards    "left_hand"
#axis_list             (  "l_thumb_oppose", "l_thumb_proximal", "l_thumb_distal", "l_index_proximal", "l_index-distal", "l_middle-proximal", "l_middle-distal", "l_little-fingers" )

axis_list             ( "l_thumb_distal", "l_index_proximal", "l_middle-proximal", "l_middle-distal", "l_little-fingers" )

joint_list                   (  "l_thumb_oppose", "l_thumb_proximal", "l_thumb_middle", "l_thumb_distal",
                                "l_index_proximal", "l_index_middle", "l_index_distal",
                                "l_middle_proximal", "l_middle_middle", "l_middle_distal",
                                "l_ring_proximal",   "l_ring_middle",   "l_ring_distal",
                                "l_pinky_proximal",   "l_pinky_middle",   "l_pinky_distal" )


# if not equal to one, consider the associated  encoder value is used for the joint readout
joint_fb_type    ( encoder , analog , analog , analog ,
                         analog , analog , analog ,
                         analog , analog , analog ,
                         analog , analog , analog ,
                         analog , analog , analog )

# probably can be deleted, since it is similar to previous info
analog_list           (  "l_thumb_proximal", "l_thumb_middle", "l_thumb_distal",
                         "l_index_proximal", "l_index_middle", "l_index_distal",
                         "l_middle_proximal", "l_middle_middle", "l_middle_distal",
                         "l_ring_proximal",   "l_ring_middle",   "l_ring_distal",
                         "l_pinky_proximal",   "l_pinky_middle",   "l_pinky_distal" )

# notice that "l_thumb_oppose" is measured by joint encoders not the analog sensors
#Adding the groups of each axis and associated analog sensors

l_thumb_oppose         ( "l_thumb_oppose" )
l_thumb_proximal       ( "l_thumb_proximal" )
l_thumb_distal         ( "l_thumb_middle", "l_thumb_distal"  )
l_index_proximal       ( "l_index_proximal" )
l_index-distal         (  "l_index_middle", "l_index_distal" )
l_middle-proximal      (  "l_middle_proximal" )
l_middle-distal        ( "l_middle_middle", "l_middle_distal" )
l_little-fingers       ( "l_ring_proximal",   "l_ring_middle",   "l_ring_distal", "l_pinky_proximal",   "l_pinky_middle",   "l_pinky_distal" )


###############
### HUMAN
###############

human_joint_list      ( "l_thumb_oppose", "l_thumb_proximal", "l_thumb_middle", "l_thumb_distal",
                         "l_index_proximal", "l_index_middle", "l_index_distal",
                         "l_middle_proximal", "l_middle_middle", "l_middle_distal",
                         "l_ring_proximal",   "l_ring_middle",   "l_ring_distal",
                         "l_pinky_proximal",   "l_pinky_middle",   "l_pinky_distal" )

human_finger_list ( "l_thumb", "l_index", "l_middle", "l_ring", "l_pinky")

###############
### RETARGETING
###############
# haptic feedback retargeting from the robot axis groups to the human finger
all_axis_list            (  "l_thumb_oppose", "l_thumb_proximal", "l_thumb_distal", "l_index_proximal", "l_index-distal", "l_middle-proximal", "l_middle-distal", "l_little-fingers" )

l_thumb                  ( "l_thumb_oppose", "l_thumb_proximal", "l_thumb_distal"  )
l_index                  ( "l_index_proximal", "l_index-distal"  )
l_middle                 ( "l_middle-proximal", "l_middle-distal"  )
l_ring                   (   "l_little-fingers" )
l_pinky                  (   "l_little-fingers" )

# This gain is multiplied tothe total error for each motor to compute the force feedback to the user, computed by user experience
# No of gains= No of motors
K_GainTotal            ( 0.0 300.0 300.0 300.0 300.0 200.0 200.0 200.0 )

# check this issue for the velocity Gain: https://github.com/dic-iit/element_retargeting-from-human/issues/141
K_GainVelocity ( 0.05 0.05 0.05 0.05 0.05 0.05 0.05 0.05 )

# this value is multiplied to forcefeedback and provides haptic feedback to the user
K_GainBuzzMotors ( 0.9 0.9 0.9 0.9 0.9 )

# scaling and biased values for maping the human to robot motion

human_to_robot_joint_anlges_scaling (  -1.0 1.0 1.0 1.0
                                        1.0 1.0 1.0
                                        1.0 1.0 1.0
                                        1.0 1.0 1.0
                                        1.0 1.0 1.0 )

human_to_robot_joint_anlges_bias    (  0.7 0.0 0.0 0.0
                                         0.0 0.0 0.0
                                         0.0 0.0 0.0
                                         0.0 0.0 0.0
                                         0.0 0.0 0.0  )

##############################
### ROBOT CONTROL & ESTIMATION
##############################

#axis_list             (  "r_thumb_oppose", "r_thumb_proximal", "r_thumb_distal", "r_index_proximal", "r_index-distal", "r_middle-proximal", "r_middle-distal", "r_little-fingers" )
# "r_thumb_oppose", "r_thumb_proximal", "r_thumb_distal", ... , "r_little-fingers" , "r_middle-proximal", "r_middle-distal"
#axis_list             (("r_hand_fingers", "r_thumb_oppose", "r_thumb_proximal", "r_thumb_distal", "r_index_proximal", "r_index_distal", "r_middle_proximal", "r_middle_distal", "r_pinky"))

useVelocity           0
noAnalogSensor        15
noAllJoints           16
noAllAxis             8

# minimum and maximum values of the joints
# only index finger is used, analog indices: 3, 4, 5
# related to analog sensors

joints_min_boundary ( 0.0 0.0 0.0     0.0 0.0 0.0     0.0 0.0 0.0     0.0 0.0 0.0     0.0 0.0 0.0  )

joints_max_boundary ( 90.0 90.0 90.0  90.0 90.0 90.0  90.0 90.0 90.0  90.0 90.0 90.0  90.0 90.0 90.0 )

sensors_min_boundary ( 255.0 255.0 251.0   255.0 255.0 255.0    255.0 255.0 255.0     255.0 255.0 255.0    255.0 255.0 255.0  )
sensors_max_boundary ( 6.0 0.0 4.0         0.0 0.0 0.0          0.0 0.0 0.0           0.0 0.0 0.0          0.0 0.0 0.0  )

# for simpliclty
#fingersScaling        ( 1, 1, 1,    1, 1, 1,    1, 1 )
fingersScaling           1.0

# in case each joint does not have independant motor to actuate, they are coupled
motorsJointsCoupled     1

doCalibration           1
#calibrationTimePeriod [sec]
calibrationTimePeriod   2.0

# if doing the calibration process, it will use velocity control mode,
#   and will overwrite the control mode mentioned in other configuration


# q= A x m, where:
#       q (n,1) is the joint values
#       m (m,1) is the motors values
#       A (n,m) is the mapping from the motors values to the joint values

# CouplingMatrix = A : (n,m) matrix
CouplingMatrix          ( 1.1 0.0 0.0 0.0 0.0
                          0.0 1.0 1.0 0.0 0.0
                          0.0 0.0 1.0 0.0 0.0
                          0.0 0.0 0.0 0.0 1.0 )

#  joints[0] is the abduction/adduction for which we don't have any MAIS readout
# 3 numbers per finger accounting in order for the proximal and the two distal phalanxes.
# the fingers' order is: thumb, index, middle, ring, pinkie.

# in the Quadratic optimizartion problem to compute the motor values from the joint values : xT Q X + uT R u
# q_matrix_joint_motor is the list identifying the main diagonal of matrix Q: (q x q) matrix; q: is the number of desired joints to control
# r_matrix_joint_motor is the list identifying the main diagonal of matrix R: (m x m) matrix; m: is the number of desired motors to control

# for simplicity
# q_matrix_joint_motor    ( 1.0 1.0 1.0 1.0  1.0 1.0 1.0  1.0 1.0 1.0   1.0 1.0 1.0  1.0 1.0 1.0 )
q_joint_motor            1.0

# for simplicity
# r_matrix_joint_motor    ( 0.0 0.0 0.0       0.0 0.0     0.0 0.0       0.0                      )
r_joint_motor             0.0

# in the Kalman Filter problem to estimate the motor value, velocity and acceleration:
# q_matrix_kf is the list identifying the main diagonal of matrix: E[ (w(t) -w_bar(t)) (w(t) -w_bar(t))^T ], size:  m*m positive matrix,  Dx(t)= Fx(t)+ Gw(t), the process noise */
# r_matrix_kf is the list identifying the main diagonal of matrix: E[ v(t) v(t)^T ], size:  p*p positive matrix, Z(t)= Hx(t)+ v(t), the measurement noise
no_states_kf            3
no_measurement_kf       1
q_matrix_kf             ( 10.0 150.0 100000.0 )
r_matrix_kf             ( 0.0000001 )
